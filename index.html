<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Match - Premium Card Game</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="floating-particles" id="particles"></div>
    
    <!-- START SCREEN -->
    <div class="start-screen" id="startScreen">
        <h1 class="game-logo">✨ Memory Match ✨</h1>
        
        <div class="players-intro">
            <div class="player-intro">
                <div class="circle blue">1</div>
                <span>Player 1</span>
            </div>
            <div class="player-intro">
                <div class="circle red">2</div>
                <span>Player 2</span>
            </div>
        </div>
        
        <button class="start-btn" onclick="startGame()">🎮 Start Game</button>
    </div>

    <!-- GAME SCREEN -->
    <div class="game-screen" id="gameScreen">
        <div class="game-header">
            <div class="player-circle blue active" id="player1Circle">0</div>
            <div class="player-circle red" id="player2Circle">0</div>
        </div>
        
        <div class="game-area" id="gameArea"></div>
    </div>

    <!-- GAME OVER OVERLAY -->
    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <h2>🎉 Game Complete! 🎉</h2>
            <div class="winner-text" id="winnerText"></div>
            <div class="game-over-buttons">
                <button class="game-btn restart-btn" onclick="restartGame()">🔄 Play Again</button>
                <button class="game-btn exit-btn" onclick="exitGame()">🚪 Exit Game</button>
            </div>
        </div>
    </div>

    <script>
        // Sound Effects
        const sounds = {
            cardFlip: null,
            match: null,
            wrong: null,
            gameWin: null
        };

        // Initialize sounds using Web Audio API
        function initSounds() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Card flip sound (short click)
            sounds.cardFlip = () => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.1);
            };
            
            // Match found sound (success)
            sounds.match = () => {
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator1.frequency.setValueAtTime(523, audioContext.currentTime); // C5
                oscillator2.frequency.setValueAtTime(659, audioContext.currentTime); // E5
                oscillator1.frequency.setValueAtTime(784, audioContext.currentTime + 0.1); // G5
                oscillator2.frequency.setValueAtTime(1047, audioContext.currentTime + 0.1); // C6
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                
                oscillator1.start();
                oscillator2.start();
                oscillator1.stop(audioContext.currentTime + 0.4);
                oscillator2.stop(audioContext.currentTime + 0.4);
            };
            
            // Wrong match sound (negative)
            sounds.wrong = () => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.3);
            };
            
            // Game win sound (celebration)
            sounds.gameWin = () => {
                const frequencies = [523, 659, 784, 1047, 1319]; // C, E, G, C, E
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                    }, i * 100);
                });
            };
        }

        let gameState = {
            cards: [],
            flippedCards: [],
            currentPlayer: 1,
            scores: [0, 0],
            gameOver: false,
            canFlip: true,
            cardPositions: []
        };

        function createParticles() {
            const container = document.getElementById('particles');
            container.innerHTML = '';
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.width = Math.random() * 8 + 4 + 'px';
                particle.style.height = particle.style.width;
                particle.style.animationDelay = Math.random() * 8 + 's';
                particle.style.animationDuration = (Math.random() * 4 + 6) + 's';
                container.appendChild(particle);
            }
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function generateRandomPositions() {
            const gameArea = document.getElementById('gameArea');
            const areaRect = gameArea.getBoundingClientRect();
            const positions = [];
            const cardWidth = window.innerWidth <= 480 ? 45 : (window.innerWidth <= 768 ? 50 : 60);
            const cardHeight = window.innerWidth <= 480 ? 65 : (window.innerWidth <= 768 ? 75 : 90);
            const padding = 20;
            
            // Create a 5x4 grid with slight random offsets
            const cols = 5;
            const rows = 4;
            const gridWidth = (areaRect.width - padding * 2) / cols;
            const gridHeight = (areaRect.height - padding * 2) / rows;
            
            for (let i = 0; i < 20; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                // Base position in grid
                const baseX = col * gridWidth + gridWidth / 2 - cardWidth / 2 + padding;
                const baseY = row * gridHeight + gridHeight / 2 - cardHeight / 2 + padding;
                
                // Add small random offset (max 20px in any direction)
                const offsetX = (Math.random() - 0.5) * 40;
                const offsetY = (Math.random() - 0.5) * 40;
                
                positions.push({
                    x: baseX + offsetX,
                    y: baseY + offsetY,
                    rotation: (Math.random() - 0.5) * 20 // Smaller rotation range
                });
            }
            return positions;
        }

        function startGame() {
            // Initialize sounds when user interaction starts
            try {
                initSounds();
            } catch (error) {
                console.log('Audio context initialization failed:', error);
            }
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            initializeGame();
        }

        function initializeGame() {
            const numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
            const cardPairs = [...numbers, ...numbers];
            gameState.cards = shuffleArray(cardPairs);
            gameState.cardPositions = generateRandomPositions();
            
            createGameBoard();
            updatePlayerDisplay();
        }

        function createGameBoard() {
            const gameArea = document.getElementById('gameArea');
            gameArea.innerHTML = '';
            
            gameState.cards.forEach((number, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.index = index;
                card.dataset.value = number;
                card.style.left = gameState.cardPositions[index].x + 'px';
                card.style.top = gameState.cardPositions[index].y + 'px';
                card.style.transform = `rotate(${gameState.cardPositions[index].rotation}deg)`;
                card.innerHTML = `
                    <div class="card-back">?</div>
                    <div class="card-content">${number}</div>
                `;
                card.addEventListener('click', handleCardClick);
                gameArea.appendChild(card);
            });
        }

        function handleCardClick(event) {
            if (!gameState.canFlip || gameState.gameOver) return;
            
            const card = event.currentTarget;
            const index = parseInt(card.dataset.index);
            
            if (card.classList.contains('flipped') || card.classList.contains('matched')) return;
            if (gameState.flippedCards.length >= 2) return;
            
            // Play card flip sound
            try {
                sounds.cardFlip();
            } catch (error) {
                console.log('Sound play failed:', error);
            }
            
            card.classList.add('flipped');
            gameState.flippedCards.push({ element: card, index, value: parseInt(card.dataset.value) });
            
            if (gameState.flippedCards.length === 2) {
                gameState.canFlip = false;
                setTimeout(checkMatch, 1000);
            }
        }

        function checkMatch() {
            const [card1, card2] = gameState.flippedCards;
            
            if (card1.value === card2.value) {
                // Match found
                card1.element.classList.add('matched');
                card2.element.classList.add('matched');
                gameState.scores[gameState.currentPlayer - 1]++;
                
                // Play match sound
                try {
                    sounds.match();
                } catch (error) {
                    console.log('Sound play failed:', error);
                }
                
                // Animate score to player circle
                animateScoreToPlayer(card1.element, card2.element);
                
                setTimeout(() => {
                    updateScore();
                    
                    // Check if game is over
                    if (document.querySelectorAll('.card.matched').length === 20) {
                        setTimeout(endGame, 500);
                    }
                }, 1000);
            } else {
                // No match - play wrong sound and flip back
                try {
                    sounds.wrong();
                } catch (error) {
                    console.log('Sound play failed:', error);
                }
                
                setTimeout(() => {
                    card1.element.classList.remove('flipped');
                    card2.element.classList.remove('flipped');
                    switchPlayer();
                }, 600);
            }
            
            gameState.flippedCards = [];
            gameState.canFlip = true;
        }

        function animateScoreToPlayer(card1, card2) {
            const targetCircle = document.getElementById(gameState.currentPlayer === 1 ? 'player1Circle' : 'player2Circle');
            const targetRect = targetCircle.getBoundingClientRect();
            
            [card1, card2].forEach((card, i) => {
                const cardRect = card.getBoundingClientRect();
                const scoreEl = document.createElement('div');
                scoreEl.className = 'score-animation';
                scoreEl.textContent = '+1';
                scoreEl.style.left = cardRect.left + cardRect.width/2 + 'px';
                scoreEl.style.top = cardRect.top + cardRect.height/2 + 'px';
                scoreEl.style.color = gameState.currentPlayer === 1 ? '#4facfe' : '#fa709a';
                
                document.body.appendChild(scoreEl);
                
                setTimeout(() => {
                    scoreEl.style.transition = 'all 1s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    scoreEl.style.left = targetRect.left + targetRect.width/2 + 'px';
                    scoreEl.style.top = targetRect.top + targetRect.height/2 + 'px';
                    scoreEl.style.opacity = '0';
                    scoreEl.style.transform = 'scale(1.5)';
                }, i * 200);
                
                setTimeout(() => {
                    document.body.removeChild(scoreEl);
                }, 1200 + i * 200);
            });
        }

        function switchPlayer() {
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            updatePlayerDisplay();
        }

        function updatePlayerDisplay() {
            const player1 = document.getElementById('player1Circle');
            const player2 = document.getElementById('player2Circle');
            
            player1.classList.toggle('active', gameState.currentPlayer === 1);
            player2.classList.toggle('active', gameState.currentPlayer === 2);
        }

        function updateScore() {
            document.getElementById('player1Circle').textContent = gameState.scores[0];
            document.getElementById('player2Circle').textContent = gameState.scores[1];
        }

        function endGame() {
            gameState.gameOver = true;
            
            // Play game win sound
            try {
                sounds.gameWin();
            } catch (error) {
                console.log('Sound play failed:', error);
            }
            
            const overlay = document.getElementById('gameOverOverlay');
            const winnerText = document.getElementById('winnerText');
            
            if (gameState.scores[0] > gameState.scores[1]) {
                winnerText.textContent = `🔵 Player 1 wins with ${gameState.scores[0]} pairs!`;
            } else if (gameState.scores[1] > gameState.scores[0]) {
                winnerText.textContent = `🔴 Player 2 wins with ${gameState.scores[1]} pairs!`;
            } else {
                winnerText.textContent = `🤝 It's a tie! Both players found ${gameState.scores[0]} pairs!`;
            }
            
            overlay.style.display = 'flex';
        }

        function restartGame() {
            // Reset game state
            gameState = {
                cards: [],
                flippedCards: [],
                currentPlayer: 1,
                scores: [0, 0],
                gameOver: false,
                canFlip: true,
                cardPositions: []
            };
            
            // Hide game over overlay
            document.getElementById('gameOverOverlay').style.display = 'none';
            
            // Restart the game directly
            initializeGame();
        }

        function exitGame() {
            // Reset game state
            gameState = {
                cards: [],
                flippedCards: [],
                currentPlayer: 1,
                scores: [0, 0],
                gameOver: false,
                canFlip: true,
                cardPositions: []
            };
            
            // Hide game over overlay and game screen
            document.getElementById('gameOverOverlay').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            
            // Show start screen
            document.getElementById('startScreen').style.display = 'flex';
        }

        // Initialize
        createParticles();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (document.getElementById('gameScreen').style.display !== 'none') {
                gameState.cardPositions = generateRandomPositions();
                createGameBoard();
            }
        });
    </script>
</body>
</html>
